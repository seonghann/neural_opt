import torch
from typing import List


def make_q_dot(
    x_inp: List[torch.Tensor],
    symbols: List[List[str]],
    alpha: float = 1.6,
    beta: float = 2.3,
    nimages: int = 17,
    tol: float = 1e-3,
    maxiter: int = 500,
):
    import sys
    sys.path.append("/home/jhwoo/Projects/torch-geodesic-interpolate/Torch_version/")
    from BatchInterpolation import simple_redistribute
    from BatchGeodesic import BatchGeodesic

    ## 1. make input
    assert torch.all(torch.tensor([len(_x) for _x in x_inp]) == 2)
    # x_inp.shape == (nbatch,)---(2, natoms, 3)

    ## 2. Perform geodesic interpolation
    path = simple_redistribute(symbols, x_inp, nimages=nimages)
    smoother = BatchGeodesic(symbols, path, threshold=1e10, alpha=alpha, beta=beta)
    smoother.smooth(tol=tol, max_iter=maxiter)

    ## 3. Make q_dot
    qij = smoother.get_w(split=False)  # shape == (nimages, batched_nrij)
    q_0, q_1 = qij[0], qij[1]
    segment = smoother.get_segments(mid=False)[0]
    length = smoother.get_length(mid=False)
    coef = length / segment
    coef = coef.repeat_interleave(smoother.nrij)
    q_dot = (q_1 - q_0) * coef

    return q_dot


def linear_q_dot(
    x_inp: List[torch.Tensor],
    symbols: List[List[str]],
    alpha: float = 1.6,
    beta: float = 2.3,
):
    import sys
    sys.path.append("/home/jhwoo/Projects/torch-geodesic-interpolate/Torch_version/")
    from torch_coord_utils import batch_get_bond_list, batch_morse_scaler, batch_compute_wij, get_re
    from util import to_batch 
    from itertools import chain

    assert torch.all(torch.tensor([len(_x) for _x in x_inp]) == 2)

    rij_list = batch_get_bond_list(x_inp, threshold=1e10)
    rij_list = [rij.T for rij in rij_list]
    scaler = batch_morse_scaler(alpha, beta)
    rij_list = to_batch(rij_list, key="edge_index")[0]
    rij_list = rij_list.T
    re = get_re(rij_list, list(chain.from_iterable(symbols)))
    x_inp = to_batch(x_inp, key="path")[0]
    wij = batch_compute_wij(x_inp, rij_list, scaler, re) 

    q_dot = wij[1] - wij[0]
    return q_dot


if __name__ == "__main__":
    import sys
    sys.path.append("/home/jhwoo/Projects/torch-geodesic-interpolate/Torch_version")
    import argparse

    default_filename = "/home/jhwoo/Projects/torch-geodesic-interpolate/Torch_version/test_cases/rxn0.xyz"
    default_filename = "/home/share/DATA/NeuralOpt/SQM_data/GeodesictoDFT/rxn000000-geodesic-geodesic.xyz"

    ps = argparse.ArgumentParser()
    ps.add_argument("--filename", type=str, nargs="+", default=[default_filename])
    ps.add_argument("--device", type=str, default="cpu", choices=["cpu", "cuda"])
    args = ps.parse_args()
    print(args)
    ##############################################################################


    from fileio import read_xyz, write_xyz
    import numpy as np

    torch.set_printoptions(linewidth=200, edgeitems=100, precision=4, sci_mode=False)

    symbols, X = [], []
    for filename in args.filename:
        _sym, _X = read_xyz(filename)
        symbols.append(_sym)
        X.append(np.array(_X))

    dtype = torch.float32
    device = torch.device(args.device)
    # X = [torch.tensor(p, dtype=dtype, device=torch.device(args.device)) for p in X]
    select_idx = torch.tensor([0, -1]); print(f"Debug: Select index with select_idx={select_idx}")
    X = [torch.tensor(p, dtype=dtype, device=torch.device(args.device))[select_idx] for p in X]
    #####################################################################
    print(f"Debug: X.shape={[x.shape for x in X]}")


    def restore_matrix_with_upper_triangle_values(upper_triangle_values):
        # upper_triangle_values의 길이를 계산하여 행렬의 크기를 결정합니다.
        n = int(torch.sqrt(torch.tensor(1 + 8 * len(upper_triangle_values))) - 1) // 2
        
        # 대각선을 포함한 하삼각행렬의 값을 0으로 채웁니다.
        restored_matrix = torch.tril(torch.zeros(n, n), diagonal=-1)
        
        # 상삼각행렬 값을 이용하여 새로운 행렬을 생성합니다.
        idx = 0
        for i in range(n):
            for j in range(i + 1, n):
                restored_matrix[i, j] = upper_triangle_values[idx]
                idx += 1
        
        return restored_matrix


    # q_dot = make_q_dot(X, symbols)
    q_dot = make_q_dot(X, symbols, nimages=30, tol=1e-4, maxiter=1000)
    print(f"Debug: q_dot.norm()={q_dot.norm().item()}")
    print(f"q_dot=\n{restore_matrix_with_upper_triangle_values(q_dot).detach()}")
    # q_dot = restore_matrix_with_upper_triangle_values(q_dot)
    # print("q_dot generated by geodesic interpolation")
    # print(q_dot.detach())

    q_dot_linear = linear_q_dot(X, symbols)
    print(f"Debug: q_dot_linear.norm()={q_dot_linear.norm().item()}")
    print(f"q_dot_linear=\n{restore_matrix_with_upper_triangle_values(q_dot_linear).detach()}")
    # q_dot_linear = restore_matrix_with_upper_triangle_values(q_dot_linear)
    # print("Linear q_dot")
    # print(q_dot.detach())

    diff_norm = (q_dot_linear - q_dot).norm()
    print(f"diff_norm = {diff_norm}")
    print(f"norm_perr = {diff_norm / q_dot.norm()}")

    cosine_angle = (q_dot_linear * q_dot).sum() / q_dot.norm() / q_dot_linear.norm()
    print(f"cosine_angle: {cosine_angle}")
    print(f"angle (degree): {torch.acos(cosine_angle) * 180 / torch.pi}")
